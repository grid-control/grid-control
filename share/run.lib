#!/bin/sh
# Author: Fred Stober <stober@ekp.uni-karlsruhe.de>

# Error codes
# 101 - file not found
# 102 - directory not found
# 103 - executable not found
# 104 - variable not found

# 105 - env unpacking failed
# 106 - se copy error

# 120 - lower space limit
# 121 - upper space limit
# 122 - min size failure

# 123 - user intervention requested

# >125 - reserved by POSIX

GC_VERSION="$Revision: 848$"

debug_helper() {
	return
	echo  -n "$$:shell:" 1>&2
	for i in `seq ${#BASH_LINENO[*]} -1 0`; do
		[ -n "${BASH_LINENO[$i]}" ] && echo -n "${BASH_LINENO[$i]} " 1>&2
		[ -n "${BASH_SOURCE[$i]}" ] && echo -n "`basename ${BASH_SOURCE[$i]}`:" 1>&2
		[ -n "${FUNCNAME[$i]}" ] && echo -n "${FUNCNAME[$i]}:" 1>&2
	done
	echo "$LINENO ($1)" 1>&2
}

fail() {
	debug_helper $FUNCNAME $LINENO
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	[ -n "$1" ] && CODE=$1 || CODE=$?
	cleanup
	updatejobinfo $CODE
	exit $CODE
}

abort() {
	debug_helper $FUNCNAME $LINENO
	[ -d "$MY_LANDINGZONE" ] && checkdir "Start directory" "$MY_LANDINGZONE" >> $MY_LANDINGZONE/stderr.txt
	[ -d "$MY_SCRATCH" ] && checkdir "Scratch directory" "$MY_SCRATCH" >> $MY_LANDINGZONE/stderr.txt
	cleanup
	[ -n "$1" ] && updatejobinfo $1
	trap - 0 1 2 3 15
	kill4sure $$
}

kill4sure() {
	debug_helper $FUNCNAME $LINENO
	DEPTH=${2:-0}
	if [ $DEPTH -lt 5 ]; then
		(ps -o pid= --ppid $1 2> /dev/null) | while read XPID; do
			kill4sure $XPID $[$DEPTH + 1] &> /dev/null
		done
	fi
	echo "Killing process $1" 1>&2
	kill -15 $1 &> /dev/null
	sleep 1
	kill -9 $1 &> /dev/null
}

updatejobinfo() {
	debug_helper $FUNCNAME $LINENO
	if [ -d "$MY_LANDINGZONE" ]; then
		(
			echo "JOBID=$MY_JOBID"
			echo "EXITCODE=$1"
		) > $MY_LANDINGZONE/jobinfo.txt
	fi
}

checkfile() {
	debug_helper $FUNCNAME $LINENO
	echo -n "Checking for file $1 ... "
	if [ ! -f "$1" ]; then
		echo "FAILED"
		echo "`basename $1` missing" 1>&2
		fail 101
	else
		echo "OK"
	fi
}

checkdir() {
	debug_helper $FUNCNAME $LINENO
	echo -e "$1:\n$2"
	[ ! -d "$2" ] && echo "$1 not found" 1>&2 && fail 102
	[ "$2" == "invalid" ] && echo "Directory $1" 1>&2 && fail 102
	getrealdir $2 && echo "$1 content:" && ls -al $2 && df -hP . && echo
}

checkbin() {
	debug_helper $FUNCNAME $LINENO
	echo -n "Checking for binary $1 ... "
	if [ -x "$1" ]; then
		echo "OK"
	elif [ -x "`getcommand $1`" ]; then
		echo "OK (`getcommand $1`)"
	else
		echo "FAILED"
		echo "`basename $1` missing" 1>&2
		fail 103
	fi
}

checkvar() {
	debug_helper $FUNCNAME $LINENO
	echo -n "Checking for variable \$$1 ... "
	if [ -z "${!1}" ]; then
		echo "FAILED"
		echo "$1 not set" 1>&2
		fail 104
	else
		echo "OK (\$$1 = ${!1})"
	fi
}

getrealdir() {
	debug_helper $FUNCNAME $LINENO
	[ -d "$1" ] && cd $1 && pwd -P && cd $OLDPWD && return `true`;
	return `false`
}

getscratch() {
	debug_helper $FUNCNAME $LINENO
	# find scratch directory with highest amount of disk space
	MY_SCRATCH="invalid"

	# getscratch_internal <list of variables> 
	# it will return with the path pointing at the biggest amount of free space
	# if no none of the directories exist, it returns 1
	getscratch_internal() {
		debug_helper $FUNCNAME $LINENO
		MY_SCRATCH="invalid"
		MY_SCRATCHSIZE=-1
		
		# find scratch directory with highest amount of disk space
		for DIRVAR in $@;
		do
			# Is variable defined?
			if [ -n "${!DIRVAR}" ]; then
				DIR=${!DIRVAR}
				# If the variable points to a nonexisting directory continue with the other vars
				[ ! -d "$DIR" ] && continue
				# Make sure we can write to the directory
				rm -Rf "$DIR/$$" &> /dev/null
				mkdir -p "$DIR/$$" &> /dev/null
				if [ -d "$DIR/$$" ]; then
					# Get free space
					SIZE="`getdiskspace $DIR/$$`" &> /dev/null
					# If it is the biggest space, use it!
					[ "$SIZE" -gt "$MY_SCRATCHSIZE" ] && MY_SCRATCH="$DIR/$$" && MY_SCRATCHSIZE="$SIZE" &> /dev/null
					rm -rf "$DIR/$$" &> /dev/null
				fi
			fi
		done
		# Was a scratch directory found?
		if [ "$MY_SCRATCHSIZE" -gt 0 ]; then
			mkdir -p "$MY_SCRATCH" &> /dev/null
			echo $MY_SCRATCH
			return 0;
		fi
		return 1;
	}

	getscratch_internal SCRATCH_DIRECTORY LOCAL_SCRATCH NODE_SCRATCH USER_SCRATCH EDG_WL_SCRATCH OSG_WN_TMP LCG_TMP DG_WL_SCRATCH && return 0
	echo "Site doesn't define scratch directory variables! Trying other locations..." 1>&2
	export 1>&2

	# FAIL or continue?
	#fail 123
	getscratch_internal MY_LANDINGZONE && return 0

	export GC_TMP="/tmp"
	getscratch_internal HOME TMPDIR GC_TMP && return 0

	fail 102
}

# Clean up user area
cleanup() {
	debug_helper $FUNCNAME $LINENO
	[ -d "$MY_LANDINGZONE" ] && cd "$MY_LANDINGZONE"
	[ -f "$MY_MARKER" ] && rm -Rf "$MY_MARKER" &> /dev/null
	[ -d "$MY_SCRATCH" ] && rm -Rf "$MY_SCRATCH" &> /dev/null
}

# TODO: choose grid commands
getcommand() {
	debug_helper $FUNCNAME $LINENO
	which $@ 2> /dev/null | head -n 1
}

_find() {
	debug_helper $FUNCNAME $LINENO
	if test -f "`pwd`/$1"; then
		echo "`pwd`/$1"
	elif test -f "$MY_SCRATCH/$1"; then
		echo "$MY_SCRATCH/$1"
	elif test -f "$MY_LANDINGZONE/$1"; then
		echo "$MY_LANDINGZONE/$1"
	else
		echo "$1 not found" 2>&1
	fi
}

var_replacer() {
	debug_helper $FUNCNAME $LINENO
	j=0
	for i in $SEEDS; do
		eval "export SEED_$j=$[i+$MY_JOBID]"
		j=$[j+1]
	done

	MYDATE=`date +%F`
	MYTIMESTAMP=`date +%s`
	(
		echo "BEGIN{srand($MY_SEED)}"
		echo "{"
		echo "	gsub(\"__X__\", \"$1\")"
		cat "$MY_SCRATCH/_varmap.dat" | while read USER_VARNAME REAL_VARNAME; do
			VARVALUE=${!REAL_VARNAME}
			echo "	gsub(\"__${USER_VARNAME}__\", \"${VARVALUE//\"/\\\"}\")"
		done
		echo "	gsub(\"__RANDOM__\", int(rand() * 900000000))"
		echo "	print"
		echo "}"
	) > "$MY_SCRATCH/_replace.awk"
	awk -f "$MY_SCRATCH/_replace.awk"
}

# Get used space in mb
getdiskusage() {
	debug_helper $FUNCNAME $LINENO
	TMPVAR="`du --block-size=m -s $1 | awk '{gsub("M", "", $1); print $1}'`"
	echo ${TMPVAR:-100000000}
}

# Get free space in mb
getdiskspace() {
	debug_helper $FUNCNAME $LINENO
	TMPVAR="`df --block-size=m -P $1 | awk 'END{gsub("M", "", $4); print $4}'`"
	echo ${TMPVAR:-0}
}

# Check for disk usage: <env var limit prefix> <dir>
monitordirlimits() {
	debug_helper $FUNCNAME $LINENO
	LIMIT_LL="${1}_LL"
	LIMIT_UL="${1}_UL"
	[ "$1" == "SCRATCH" ] && DEFAULT_LL=100 || DEFAULT_LL=1000
	[ "$1" == "SCRATCH" ] && DEFAULT_UL=50 || DEFAULT_UL=100
	while [ -f "$MY_MARKER" ]; do
		[ -z "$MDL_CFG" -a -f "$MY_SCRATCH/_config.sh" ] && source "$MY_SCRATCH/_config.sh" && MDL_CFG="set"
		DISKSPACE="`getdiskspace $2`"
		if [ $DISKSPACE -lt ${!LIMIT_LL:-$DEFAULT_LL} ]; then
			echo "Lower space limit reached on $2" 1>&2
			updatejobinfo 120
			kill -SIGTERM $$
		fi
		DISKUSAGE="`getdiskusage $2`"
		if [ $DISKUSAGE -gt ${!LIMIT_UL:-$DEFAULT_UL} ]; then
			echo "Upper space limit reached on $2" 1>&2
			updatejobinfo 121
			kill -SIGTERM $$
		fi
		sleep 20;
	done
}

url_exists() {
	case "$1" in
		"gsiftp://"*)	TOOL="`getcommand glite-gridftp-exists edg-gridftp-exists lcg-ls`"
							echo "$TOOL $1"
							$TOOL $1 > /dev/null;;
		"file://"*)		echo "test -f ${1#file://}"
							test -f ${1#file://};;
		"srm://"*)		TOOL="srm-check-permissions"
							echo "$TOOL $1"
							$TOOL $1 > /dev/null;;
		*)					echo "Unsupported URL: $1" >&2 && fail 106;;
	esac
}

url_rm_tool() {
	TOOL="`getcommand glite-gridftp-rm edg-gridftp-rm lcg-rm`"
	case "$1" in
		"gsiftp://"*)	;;
		"file://"*)		TOOL="rm";;
		"srm://"*)		TOOL="srmrm -2";;
		*)					echo "Unsupported URL: $1" >&2 && fail 106;;
	esac
	echo $TOOL
}

# Remove file from storage element
url_rm() {
	debug_helper $FUNCNAME $LINENO
	for PARAM in `seq 1 $#`; do
		FILE=${!PARAM}
		echo "`url_rm_tool $FILE` ${FILE#file://}"
		`url_rm_tool $FILE` ${FILE#file://}
	done
}

# Selects best suited copy tool for source -> target
url_copy_tool() {
	# TODO: checkbin $TOOL
	debug_helper $FUNCNAME $LINENO
	TOOL="globus-url-copy"
	# TODO: select lcg-cp on non-OSG sites
	FILE1='false'
	case "$1" in
		"gsiftp://"*)	;;
		"file://"*)		FILE1='true';;
		"srm://"*)		echo "srmcp -2 -debug=true -streams_num=1" && return;;
		*)					echo "Unsupported URL: $1" >&2 && fail 106;;
	esac
	FILE2='false'
	case "$2" in
		"gsiftp://"*)	;;
		"file://"*)		FILE2='true';;
		"srm://"*)		echo "srmcp -2 -debug=true -streams_num=1" && return;;
		*)					echo "Unsupported URL: $1" >&2 && fail 106;;
	esac
	[ "$FILE1" == "true" -a "$FILE2" == "true" ] && TOOL="url_copy_tool_file2file"
	echo $TOOL
}

url_copy_tool_file2file() {
	[ ! -f "${1#file://}" ] && fail 106
	[ -f "${2#file://}" ] && fail 106
	cp ${1#file://} ${2#file://}
}

# Copy one file at a time (1) -> (2)
url_copy_single() {
	debug_helper $FUNCNAME $LINENO
	echo "`url_copy_tool $1 $2` $1 $2"
	`url_copy_tool $1 $2` $1 $2
}

# Copy one file at a time (1) -> (2) 
url_copy_single_force() {
	debug_helper $FUNCNAME $LINENO
	url_exists $2 && echo "File exists! Delete $2" && url_rm $2
	url_copy_single $1 $2
}

# Copy serveral files with specified pattern
url_copy() {
	debug_helper $FUNCNAME $LINENO
	#checkbin "globus-url-copy" || fail 103
	echo "Copy $3 from $1 to $2"
	case "$1" in
		"gsiftp://"*)
			# copy from SE to WN
			TARGET_PATTERN="__X__"
			if [[ "$3" == *\** ]]; then
				# Wildcard used => gridftp-ls
				GRIDFTP_LS="`getcommand glite-gridftp-ls edg-gridftp-ls`"
				checkbin ${GRIDFTP_LS:-"glite-gridftp-ls"} || fail 103
				for pat1 in $3; do
					pat="`echo ${SE_INPUT_PATTERN:-__X__} | var_replacer $pat1`"
					for file in "`$GRIDFTP_LS $1/$pat`"; do
						[ -n "$file" ] && SOURCE_FILES="$SOURCE_FILES `basename $file`"
					done
				done
			else
				SOURCE_FILES="`echo ${SE_INPUT_PATTERN:-__X__} | var_replacer $3`"
			fi
			;;
		"srm://"*)
			# copy from SE to WN
			TARGET_PATTERN="__X__"
			if [[ "$3" == *\** ]]; then
				echo "Wildcards not supported for SRM" && fail 106
			else
				SOURCE_FILES="`echo ${SE_INPUT_PATTERN:-__X__} | var_replacer $3`"
			fi
			;;
		"file://"*)
			# copy from site to SE
			TARGET_PATTERN="${SE_OUTPUT_PATTERN:-__X__}"
			SOURCE_FILES="`cd ${1#file://} && ls -d $3 && cd $OLDPWD`"
			# Check that file size is larger than SE_MINFILESIZE
			for file in $SOURCE_FILES; do
				[ -d "$file" ] && continue
				SOURCE_FN="`echo ${SOURCE_PATTERN:-__X__} | var_replacer $file`"
				[ "`getdiskusage ${1#file://}/$SOURCE_FN`" -lt "${SE_MINFILESIZE:-0}" ] && fail 122
			done
			;;
		*)
			echo "Unsupported URL: $1" && fail 106
			;;
	esac

	BADCOUNT=0
	for file in $SOURCE_FILES; do
		[ -d "$file" ] && continue
		SOURCE_FN="`echo ${SOURCE_PATTERN:-__X__} | var_replacer $file`"
		TARGET_FN="`echo ${TARGET_PATTERN:-__X__} | var_replacer $file`"
		[ -n "$TRANSFERLOG" ] && echo "$SOURCE_FN $TARGET_FN" >> "$TRANSFERLOG"
		url_copy_single "$1/$SOURCE_FN" "$2/$TARGET_FN"
		RESULT=$?
		echo "url_copy_single \"$1/$SOURCE_FN\" \"$2/$TARGET_FN\" returned with $RESULT"
		# [ $RESULT != 0 ] && BADCOUNT=$[$BADCOUNT+1]
	done
	[ $BADCOUNT -ne 0 ] && echo "$BADCOUNT errors occurred during SE access" && fail 106
}

url_move() {
	debug_helper $FUNCNAME $LINENO
	for PARAM in `seq 1 $[$# - 1]`; do
		echo "move ${!PARAM}"
	done
}

my_move() {
	debug_helper $FUNCNAME $LINENO
	[ ! -d "$1" ] && fail 102
	[ ! -d "$2" ] && fail 102
	[ -z "$3" ] && return
	echo "Move files from $1 to $2:"
	for file in `cd $1 && ls $(eval "echo $3") && cd $OLDPWD`; do
		echo -e " >> $file"
		test -f "$1/$file" && mv "$1/$file" "$2/$file"
	done
}
